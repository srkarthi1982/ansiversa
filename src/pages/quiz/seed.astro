---
import Layout from "../../layouts/Layout.astro";
import {
  loadQuestionDataset,
  questionDatasetMetadata,
  type QuestionDatasetKey,
} from "../../utils/questionDatasets";

const datasetSummaries = await Promise.all(
  questionDatasetMetadata.map(async (meta) => {
    const raw = await loadQuestionDataset(meta.id as QuestionDatasetKey);
    const totalRecords = Array.isArray(raw) ? raw.length : 0;
    return {
      ...meta,
      totalRecords,
    };
  }),
);

const seederConfig = {
  datasets: datasetSummaries,
  defaultDatasetId: datasetSummaries[0]?.id ?? null,
};
---
<Layout>
  <main class="min-h-screen bg-slate-50">
    <section class="py-12">
      <div class="mx-auto flex max-w-5xl flex-col gap-8 px-4 sm:px-6 lg:px-8">
        <header class="space-y-3">
          <p class="inline-flex items-center gap-2 rounded-full bg-indigo-100 px-4 py-1 text-sm font-semibold text-indigo-700">
            <i class="fas fa-database text-xs"></i>
            Question seeder
          </p>
          <h1 class="text-3xl font-bold text-slate-900 sm:text-4xl">Seed quiz questions in controllable batches</h1>
          <p class="text-sm text-slate-600 sm:text-base">
            Pick a dataset, define how many records you want to push per request, and watch the import advance chunk by chunk.
            The flow runs entirely on demand so you can pause, inspect, and resume whenever needed.
          </p>
        </header>

        <section
          class="grid gap-6 rounded-3xl border border-slate-200 bg-white p-6 shadow-[0_24px_60px_-32px_rgba(15,23,42,0.15)]"
          x-data={`questionSeeder(${JSON.stringify(seederConfig)})`}
        >
          <div class="grid gap-4 sm:grid-cols-2">
            <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4">
              <label class="block text-xs font-semibold uppercase tracking-wide text-slate-500">
                Dataset
              </label>
              <select
                class="mt-2 w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
                x-model="selectedDatasetId"
                :disabled="running || processedRecords > 0 || datasets.length === 0"
              >
                <template x-if="datasets.length === 0">
                  <option value="" disabled>No datasets configured</option>
                </template>
                <template x-for="dataset in datasets" :key="dataset.id">
                  <option :value="dataset.id" x-text="dataset.label"></option>
                </template>
              </select>
              <dl class="mt-4 space-y-2 text-xs text-slate-500">
                <div class="flex items-center gap-2">
                  <span class="font-semibold text-slate-600">Description:</span>
                  <span x-text="currentDataset?.description ?? '—'"></span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="font-semibold text-slate-600">Source file:</span>
                  <code class="rounded bg-slate-200 px-1 py-0.5 text-[11px]" x-text="currentDataset?.fileName ?? '—'"></code>
                </div>
              </dl>
            </article>

            <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4">
              <label class="block text-xs font-semibold uppercase tracking-wide text-slate-500">
                Chunk size per request
              </label>
              <div class="mt-2 flex items-center gap-3">
                <input
                  type="number"
                  min="1"
                  step="1"
                  class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 shadow-inner focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
                  x-model.number="chunkSize"
                  :disabled="running || processedRecords > 0 || !currentDataset"
                />
                <button
                  type="button"
                  class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-600 transition hover:border-slate-300 hover:text-slate-800 disabled:cursor-not-allowed disabled:opacity-70"
                  x-on:click="setDefaultChunkSize"
                  :disabled="running || processedRecords > 0 || !currentDataset"
                >
                  <i class="fas fa-clock-rotate-left text-[10px]"></i>
                  Default
                </button>
              </div>
              <p class="mt-3 text-xs text-slate-500">
                Default chunk: <span class="font-semibold text-slate-700" x-text="datasetDefaultChunkSize.toLocaleString()"></span> records •
                Expected batches: <span class="font-semibold text-slate-700" x-text="totalChunks.toLocaleString()"></span>
              </p>
            </article>
          </div>

          <div class="grid gap-4 sm:grid-cols-3 sm:gap-6">
            <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4 text-sm text-slate-600">
              <p class="text-xs font-semibold uppercase tracking-wide text-slate-500">Dataset records</p>
              <p class="mt-2 text-2xl font-semibold text-slate-900" x-text="totalRecords.toLocaleString()"></p>
              <p class="mt-1 text-xs text-slate-500">
                Total rows available in the selected dataset.
              </p>
            </article>
            <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4 text-sm text-slate-600">
              <p class="text-xs font-semibold uppercase tracking-wide text-slate-500">Chunk size</p>
              <p class="mt-2 text-2xl font-semibold text-slate-900" x-text="chunkSize.toLocaleString()"></p>
              <p class="mt-1 text-xs text-slate-500">
                Records processed per API call.
              </p>
            </article>
            <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4 text-sm text-slate-600">
              <p class="text-xs font-semibold uppercase tracking-wide text-slate-500">Remaining records</p>
              <p class="mt-2 text-2xl font-semibold text-slate-900" x-text="remainingRecords.toLocaleString()"></p>
              <p class="mt-1 text-xs text-slate-500">
                Updated after every chunk completion.
              </p>
            </article>
          </div>

          <div class="space-y-4">
            <div class="rounded-2xl border border-slate-200 bg-slate-50 p-5">
              <div class="mb-3 flex flex-wrap items-center justify-between gap-3 text-sm text-slate-600">
                <div class="space-y-1">
                  <p class="text-base font-semibold text-slate-900">
                    Progress: <span x-text="`${processedRecords.toLocaleString()} / ${totalRecords.toLocaleString()} records`"></span>
                  </p>
                  <p>
                    <span class="font-semibold text-emerald-600" x-text="inserted.toLocaleString()"></span> inserted,
                    <span class="font-semibold text-amber-600" x-text="skipped.toLocaleString()"></span> skipped
                  </p>
                </div>
                <div class="flex items-center gap-2">
                  <span
                    class="inline-flex items-center gap-2 rounded-full border px-3 py-1 text-xs font-semibold"
                    :class="completed ? 'border-emerald-200 bg-emerald-50 text-emerald-700' : running ? 'border-indigo-200 bg-indigo-50 text-indigo-700' : 'border-slate-200 bg-white text-slate-600'"
                  >
                    <span class="flex h-1.5 w-1.5 rounded-full"
                      :class="completed ? 'bg-emerald-500' : running ? 'bg-indigo-500 animate-pulse' : 'bg-slate-400'"></span>
                    <span x-text="statusLabel"></span>
                  </span>
                </div>
              </div>
              <div class="h-2 w-full overflow-hidden rounded-full bg-slate-200">
                <div
                  class="h-full rounded-full bg-indigo-500 transition-[width]"
                  :style="`width: ${progressPercent}%;`"
                ></div>
              </div>
            </div>

            <div class="flex flex-wrap items-center gap-3">
              <button
                type="button"
                class="inline-flex items-center gap-2 rounded-full bg-indigo-600 px-5 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:bg-indigo-300"
                x-on:click="start"
                :disabled="running || completed || !currentDataset"
              >
                <span class="flex h-3 w-3 items-center justify-center">
                  <span
                    class="inline-flex h-3 w-3 items-center justify-center"
                    :class="running ? 'animate-spin' : ''"
                  >
                    <i class="fas" :class="running ? 'fa-circle-notch' : 'fa-play'"></i>
                  </span>
                </span>
                <span x-text="running ? 'Processing…' : completed ? 'Completed' : 'Start seeding'"></span>
              </button>
              <button
                type="button"
                class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-5 py-2 text-sm font-semibold text-slate-600 transition hover:border-slate-300 hover:text-slate-800 disabled:cursor-not-allowed disabled:opacity-70"
                x-on:click="resetProgress"
                :disabled="running || (processedRecords === 0 && !error)"
              >
                <i class="fas fa-rotate-left text-xs"></i>
                Reset progress
              </button>
              <template x-if="error">
                <div class="inline-flex items-center gap-2 rounded-full border border-red-200 bg-red-50 px-4 py-2 text-xs font-semibold text-red-600">
                  <i class="fas fa-exclamation-triangle text-[10px]"></i>
                  <span x-text="error"></span>
                </div>
              </template>
            </div>
          </div>

        </section>
      </div>
    </section>
  </main>
</Layout>

<script is:inline>
  function questionSeeder(config) {
    const datasets = Array.isArray(config?.datasets) ? config.datasets : [];
    const defaultDatasetId = typeof config?.defaultDatasetId === 'string' ? config.defaultDatasetId : datasets[0]?.id ?? null;
    const defaultDataset = datasets.find((item) => item.id === defaultDatasetId) ?? datasets[0] ?? null;
    const initialChunkSize = Math.max(1, Math.floor(Number(defaultDataset?.defaultChunkSize) || 1000));

    return {
      datasets,
      selectedDatasetId: defaultDataset?.id ?? null,
      chunkSize: initialChunkSize,
      currentChunk: 0,
      processedRecords: 0,
      inserted: 0,
      skipped: 0,
      running: false,
      completed: false,
      error: null,
      get currentDataset() {
        return this.datasets.find((item) => item.id === this.selectedDatasetId) ?? null;
      },
      get totalRecords() {
        return Number(this.currentDataset?.totalRecords) || 0;
      },
      get datasetDefaultChunkSize() {
        return Math.max(1, Math.floor(Number(this.currentDataset?.defaultChunkSize) || 1000));
      },
      get totalChunks() {
        if (!this.totalRecords) return 0;
        const size = Math.max(1, Math.floor(Number(this.chunkSize) || 0));
        if (!size) return 0;
        return Math.ceil(this.totalRecords / size);
      },
      get remainingRecords() {
        return Math.max(this.totalRecords - this.processedRecords, 0);
      },
      get progressPercent() {
        if (!this.totalRecords) return 0;
        const percent = (this.processedRecords / this.totalRecords) * 100;
        return Math.max(0, Math.min(100, Math.round(percent)));
      },
      get statusLabel() {
        if (this.completed) return 'Completed';
        if (this.running) return `Running chunk ${this.currentChunk + 1} of ${this.totalChunks}`;
        if (this.processedRecords > 0) return 'Ready to resume';
        return 'Idle';
      },
      init() {
        this.$watch('selectedDatasetId', () => {
          this.chunkSize = this.datasetDefaultChunkSize;
          this.resetProgress();
        });
        this.$watch('chunkSize', (value, oldValue) => {
          const numeric = Math.max(1, Math.floor(Number(value)));
          if (!Number.isFinite(numeric) || numeric <= 0) {
            const fallback = Math.max(1, Math.floor(Number(oldValue)));
            this.chunkSize = Number.isFinite(fallback) && fallback > 0 ? fallback : this.datasetDefaultChunkSize;
          } else if (numeric !== value) {
            this.chunkSize = numeric;
          }
        });
      },
      setDefaultChunkSize() {
        if (this.running) return;
        this.chunkSize = this.datasetDefaultChunkSize;
      },
      async start() {
        if (this.running) {
          return;
        }
        if (!this.currentDataset) {
          this.error = 'Select a dataset to begin.';
          return;
        }
        if (!Number.isFinite(this.chunkSize) || this.chunkSize <= 0) {
          this.error = 'Chunk size must be greater than zero.';
          return;
        }
        this.chunkSize = Math.max(1, Math.floor(Number(this.chunkSize)));
        const totalChunks = this.totalChunks;

        this.running = true;
        this.completed = false;
        this.error = null;

        try {
          for (let chunkIndex = this.currentChunk; chunkIndex < totalChunks; chunkIndex += 1) {
            const result = await this.runChunk(chunkIndex);
            if (!result.ok) {
              this.error = result.error ?? 'Unable to process chunk';
              break;
            }

            const payload = result.payload;
            const totalRecords = Number(payload.totalRecords) || this.totalRecords;

            this.inserted += Number(payload.inserted) || 0;
            this.skipped += Number(payload.skipped) || 0;
            this.processedRecords = Math.min(
              Number(payload.processedRecords) || this.processedRecords,
              totalRecords,
            );

        this.currentChunk = chunkIndex + 1;

            if (payload.done) {
              this.completed = true;
              break;
            }
          }
        } finally {
          this.running = false;
          if (this.currentChunk >= this.totalChunks || this.processedRecords >= this.totalRecords) {
            this.completed = true;
          }
        }
      },
      async runChunk(index) {
        try {
          const response = await fetch('/api/quiz/seed', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              dataset: this.currentDataset.id,
              chunk: index,
              chunkSize: Math.max(1, Math.floor(Number(this.chunkSize))),
            }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            return { ok: false, error: errorText || 'Failed request' };
          }

          const payload = await response.json();
          return { ok: true, payload };
        } catch (err) {
          return {
            ok: false,
            error: err instanceof Error ? err.message : 'Unexpected error while processing chunk',
          };
        }
      },
      resetProgress() {
        if (this.running) return;
        this.currentChunk = 0;
        this.processedRecords = 0;
        this.inserted = 0;
        this.skipped = 0;
        this.completed = false;
        this.error = null;
      },
    };
  }
</script>
